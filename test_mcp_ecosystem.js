#!/usr/bin/env node

// üß™ Script de test de compatibilit√© de l'√©cosyst√®me MCP
// V√©rifie que tous les serveurs MCP install√©s fonctionnent correctement

import { spawn } from 'child_process';
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Couleurs pour les messages
const colors = {
  reset: '\033[0m',
  red: '\033[0;31m',
  green: '\033[0;32m',
  yellow: '\033[1;33m',
  blue: '\033[0;34m',
  cyan: '\033[0;36m',
  magenta: '\033[0;35m'
};

function log(color, icon, message) {
  console.log(`${colors[color]}${icon} ${message}${colors.reset}`);
}

function logInfo(message) { log('blue', '‚ÑπÔ∏è ', message); }
function logSuccess(message) { log('green', '‚úÖ', message); }
function logWarning(message) { log('yellow', '‚ö†Ô∏è ', message); }
function logError(message) { log('red', '‚ùå', message); }
function logTest(message) { log('cyan', 'üîç', message); }

// Fonction pour v√©rifier si une commande existe
async function commandExists(command) {
  return new Promise((resolve) => {
    const process = spawn('which', [command], { stdio: 'ignore' });
    process.on('close', (code) => {
      resolve(code === 0);
    });
  });
}

// Fonction pour v√©rifier si un package npm est install√© globalement
async function npmPackageExists(packageName) {
  return new Promise((resolve) => {
    const process = spawn('npm', ['list', '-g', packageName], { stdio: 'ignore' });
    process.on('close', (code) => {
      resolve(code === 0);
    });
  });
}

// Fonction pour v√©rifier si un r√©pertoire existe
async function directoryExists(dirPath) {
  try {
    const stat = await fs.stat(dirPath);
    return stat.isDirectory();
  } catch {
    return false;
  }
}

// Fonction pour tester un serveur MCP en mode basic (v√©rifier qu'il d√©marre)
async function testMcpServer(serverName, command, args = []) {
  return new Promise((resolve) => {
    logTest(`Test de d√©marrage de ${serverName}...`);
    
    const process = spawn(command, args, { 
      stdio: 'ignore',
      timeout: 5000
    });
    
    let resolved = false;
    
    // Si le processus d√©marre et reste actif pendant 2 secondes, c'est bon
    const successTimer = setTimeout(() => {
      if (!resolved) {
        resolved = true;
        process.kill();
        resolve({ success: true, message: 'Serveur d√©marre correctement' });
      }
    }, 2000);
    
    process.on('error', (error) => {
      if (!resolved) {
        resolved = true;
        clearTimeout(successTimer);
        resolve({ success: false, message: `Erreur: ${error.message}` });
      }
    });
    
    process.on('close', (code) => {
      if (!resolved) {
        resolved = true;
        clearTimeout(successTimer);
        if (code === 0) {
          resolve({ success: true, message: 'Serveur s\'est ferm√© proprement' });
        } else {
          resolve({ success: false, message: `Code de sortie: ${code}` });
        }
      }
    });
    
    // Timeout g√©n√©ral
    setTimeout(() => {
      if (!resolved) {
        resolved = true;
        clearTimeout(successTimer);
        process.kill();
        resolve({ success: false, message: 'Timeout - le serveur ne r√©pond pas' });
      }
    }, 8000);
  });
}

// Configuration des serveurs √† tester
const serverConfigs = [
  {
    name: 'MCP Drupal Server',
    type: 'local',
    command: 'node',
    args: [path.join(__dirname, 'dist', 'index.js')],
    required: true,
    checkMethod: async () => {
      const distExists = await directoryExists(path.join(__dirname, 'dist'));
      const indexExists = await fs.access(path.join(__dirname, 'dist', 'index.js')).then(() => true).catch(() => false);
      return distExists && indexExists;
    }
  },
  {
    name: 'Filesystem MCP Server',
    type: 'npm',
    package: '@modelcontextprotocol/server-filesystem',
    command: 'npx',
    args: ['@modelcontextprotocol/server-filesystem', __dirname],
    required: false,
    checkMethod: async () => await npmPackageExists('@modelcontextprotocol/server-filesystem')
  },
  {
    name: 'Git MCP Server',
    type: 'npm',
    package: '@modelcontextprotocol/server-git',
    command: 'npx',
    args: ['@modelcontextprotocol/server-git', '--repository', __dirname],
    required: false,
    checkMethod: async () => await npmPackageExists('@modelcontextprotocol/server-git')
  },
  {
    name: 'GitHub MCP Server',
    type: 'npm',
    package: '@modelcontextprotocol/server-github',
    command: 'npx',
    args: ['@modelcontextprotocol/server-github'],
    required: false,
    checkMethod: async () => await npmPackageExists('@modelcontextprotocol/server-github')
  },
  {
    name: 'MCP Alchemy (Database)',
    type: 'npm',
    package: 'mcp-alchemy',
    command: 'mcp-alchemy',
    args: ['--help'], // Test avec help pour √©viter les erreurs de config
    required: false,
    checkMethod: async () => await npmPackageExists('mcp-alchemy')
  },
  {
    name: 'Docker MCP Server',
    type: 'local',
    command: 'node',
    args: [path.join(process.env.HOME, '.mcp-servers', 'docker-mcp', 'dist', 'index.js')],
    required: false,
    checkMethod: async () => await directoryExists(path.join(process.env.HOME, '.mcp-servers', 'docker-mcp'))
  },
  {
    name: 'PostgreSQL MCP Server',
    type: 'local',
    command: 'node',
    args: [path.join(process.env.HOME, '.mcp-servers', 'postgres-mcp', 'dist', 'index.js')],
    required: false,
    checkMethod: async () => await directoryExists(path.join(process.env.HOME, '.mcp-servers', 'postgres-mcp'))
  }
];

async function testMcpEcosystem() {
  console.log('üß™ Test de compatibilit√© de l\'√©cosyst√®me MCP Drupal');
  console.log('=====================================================\n');
  
  const results = {
    total: 0,
    installed: 0,
    working: 0,
    failed: 0,
    servers: []
  };
  
  // V√©rification des pr√©requis
  logInfo('V√©rification des pr√©requis...');
  
  const prerequisites = [
    { name: 'Node.js', command: 'node' },
    { name: 'npm', command: 'npm' },
    { name: 'npx', command: 'npx' },
    { name: 'git', command: 'git' }
  ];
  
  for (const prereq of prerequisites) {
    if (await commandExists(prereq.command)) {
      logSuccess(`${prereq.name} est disponible`);
    } else {
      logError(`${prereq.name} n'est pas install√©`);
      process.exit(1);
    }
  }
  
  console.log('');
  
  // Test des serveurs MCP
  logInfo('Test des serveurs MCP install√©s...\n');
  
  for (const server of serverConfigs) {
    results.total++;
    
    console.log(`üîç Test de ${server.name}:`);
    
    // V√©rifier si le serveur est install√©
    const isInstalled = await server.checkMethod();
    
    if (!isInstalled) {
      if (server.required) {
        logError(`  ${server.name} est requis mais n'est pas install√©`);
        results.failed++;
        results.servers.push({
          name: server.name,
          status: 'required_missing',
          message: 'Serveur requis manquant'
        });
      } else {
        logWarning(`  ${server.name} n'est pas install√© (optionnel)`);
        results.servers.push({
          name: server.name,
          status: 'not_installed',
          message: 'Serveur optionnel non install√©'
        });
      }
      console.log('');
      continue;
    }
    
    results.installed++;
    logSuccess(`  ${server.name} est install√©`);
    
    // Tester le d√©marrage du serveur
    const testResult = await testMcpServer(server.name, server.command, server.args);
    
    if (testResult.success) {
      logSuccess(`  ${server.name} fonctionne: ${testResult.message}`);
      results.working++;
      results.servers.push({
        name: server.name,
        status: 'working',
        message: testResult.message
      });
    } else {
      logError(`  ${server.name} a √©chou√©: ${testResult.message}`);
      results.failed++;
      results.servers.push({
        name: server.name,
        status: 'failed',
        message: testResult.message
      });
    }
    
    console.log('');
  }
  
  // V√©rification de la configuration Claude Code
  logInfo('V√©rification de la configuration Claude Code...');
  
  const configPaths = [
    path.join(process.env.HOME, '.config', 'claude-code', 'mcp_config.json'),
    path.join(__dirname, 'claude_mcp_config.json'),
    path.join(process.env.HOME, 'Library', 'Application Support', 'Claude', 'claude_desktop_config.json')
  ];
  
  let configFound = false;
  for (const configPath of configPaths) {
    try {
      await fs.access(configPath);
      logSuccess(`Configuration trouv√©e: ${configPath}`);
      configFound = true;
      
      // Valider le JSON
      const configContent = await fs.readFile(configPath, 'utf8');
      try {
        const config = JSON.parse(configContent);
        if (config.mcpServers) {
          logSuccess(`  Configuration valide avec ${Object.keys(config.mcpServers).length} serveurs configur√©s`);
        } else {
          logWarning('  Configuration trouv√©e mais pas de section mcpServers');
        }
      } catch (error) {
        logError(`  Configuration invalide (JSON malform√©): ${error.message}`);
      }
      break;
    } catch {
      // Fichier n'existe pas
    }
  }
  
  if (!configFound) {
    logWarning('Aucune configuration Claude Code trouv√©e');
    logInfo('Utilisez le script install_mcp_ecosystem.sh pour g√©n√©rer une configuration');
  }
  
  console.log('');
  
  // Rapport final
  console.log('üìä RAPPORT DE COMPATIBILIT√â √âCOSYST√àME MCP');
  console.log('==========================================');
  console.log(`üì¶ Serveurs total: ${results.total}`);
  console.log(`‚úÖ Serveurs install√©s: ${results.installed}`);
  console.log(`üöÄ Serveurs fonctionnels: ${results.working}`);
  console.log(`‚ùå Serveurs en √©chec: ${results.failed}`);
  console.log(`üìä Taux de r√©ussite: ${Math.round((results.working / results.installed) * 100)}%`);
  
  console.log('\nüìã D√©tail par serveur:');
  console.log('======================');
  
  for (const server of results.servers) {
    const statusIcons = {
      'working': '‚úÖ',
      'failed': '‚ùå',
      'not_installed': '‚è∏Ô∏è ',
      'required_missing': 'üö®'
    };
    
    console.log(`${statusIcons[server.status]} ${server.name}: ${server.message}`);
  }
  
  console.log('');
  
  // Recommandations
  if (results.failed > 0) {
    logWarning('RECOMMANDATIONS:');
    console.log('1. V√©rifiez les logs d\'erreur ci-dessus');
    console.log('2. R√©installez les serveurs en √©chec avec install_mcp_ecosystem.sh');
    console.log('3. V√©rifiez les variables d\'environnement et tokens d\'acc√®s');
    console.log('4. Consultez MCP_ECOSYSTEM.md pour la configuration d√©taill√©e');
  } else if (results.working === results.installed && results.installed > 0) {
    logSuccess('PARFAIT ! Tous les serveurs install√©s fonctionnent correctement !');
    console.log('üéâ Votre √©cosyst√®me MCP Drupal est enti√®rement op√©rationnel.');
    console.log('üí° Vous pouvez maintenant utiliser Claude Code avec tous vos serveurs MCP.');
  } else if (results.installed === 0) {
    logInfo('PREMIERS PAS:');
    console.log('1. Lancez ./install_mcp_ecosystem.sh pour installer les serveurs MCP');
    console.log('2. Relancez ce test pour v√©rifier l\'installation');
    console.log('3. Consultez MCP_ECOSYSTEM.md pour les guides d\'utilisation');
  }
  
  console.log('');
  
  // Code de sortie
  const hasRequiredFailed = results.servers.some(s => s.status === 'required_missing');
  const hasWorkingServers = results.working > 0;
  
  if (hasRequiredFailed) {
    process.exit(2); // Serveurs requis manquants
  } else if (results.failed > 0 && !hasWorkingServers) {
    process.exit(1); // Tous les serveurs install√©s ont √©chou√©
  } else {
    process.exit(0); // Succ√®s ou succ√®s partiel
  }
}

// Gestion des erreurs
process.on('uncaughtException', (error) => {
  logError(`Erreur inattendue: ${error.message}`);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  logError(`Promesse rejet√©e: ${reason}`);
  process.exit(1);
});

// Lancer le test
testMcpEcosystem().catch(error => {
  logError(`Erreur lors du test: ${error.message}`);
  process.exit(1);
});